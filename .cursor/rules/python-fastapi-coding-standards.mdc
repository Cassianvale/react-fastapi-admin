---
globs: "*.py"
description: Python FastAPI 代码规范和样式指南
---

# Python FastAPI 代码规范

## 🐍 Python 代码风格

### 命名约定

- **变量和函数**: 使用 `snake_case`
- **类名**: 使用 `PascalCase`
- **常量**: 使用 `UPPER_SNAKE_CASE`
- **私有方法**: 使用前缀 `_`
- **模块名**: 使用 `lowercase` 或 `snake_case`

### 导入规范

```python
# 标准库导入
import os
import sys
from pathlib import Path

# 第三方库导入
from fastapi import FastAPI, Depends, HTTPException
from tortoise import fields
from pydantic import BaseModel

# 本地导入
from app.core.crud import CRUDBase
from app.models.admin import User
from app.schemas.users import UserCreate
```

### 类型注解

- 所有函数参数和返回值必须有类型注解
- 使用 `typing` 模块提供的类型

```python
from typing import Optional, List, Dict, Any

async def get_user(user_id: int) -> Optional[User]:
    return await User.get_or_none(id=user_id)

async def list_users(skip: int = 0, limit: int = 100) -> List[User]:
    return await User.all().offset(skip).limit(limit)
```

## 🚀 FastAPI 开发规范

### API 路由定义

```python
from fastapi import APIRouter, Depends, status
from app.core.dependency import AuthControl

router = APIRouter(prefix="/api/v1/users", tags=["用户管理"])

@router.get("/", response_model=List[UserResponse])
async def list_users(
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(AuthControl.get_current_user)
):
    """获取用户列表"""
    # 业务逻辑
    pass
```

### 响应模型规范

- 使用 Pydantic 模型定义响应结构
- 明确指定 `response_model`
- 统一的错误响应格式

### 依赖注入模式

- 使用 `Depends()` 进行依赖注入
- 权限检查通过依赖注入实现
- 数据库会话管理通过依赖注入

### 异常处理

```python
from app.core.exceptions import RecordNotFoundError
from fastapi import HTTPException, status

# 使用自定义异常
if not user:
    raise RecordNotFoundError(detail="用户不存在")

# 或使用 FastAPI HTTPException
raise HTTPException(
    status_code=status.HTTP_404_NOT_FOUND,
    detail="用户不存在"
)
```

## 🗄️ Tortoise ORM 规范

### 模型定义

```python
from tortoise import fields
from app.models.base import BaseModel, TimestampMixin

class User(BaseModel, TimestampMixin):
    username = fields.CharField(
        max_length=20,
        unique=True,
        description="用户名",
        index=True
    )
    email = fields.CharField(
        max_length=255,
        unique=True,
        description="邮箱",
        index=True
    )

    class Meta:
        table = "user"
```

### 查询规范

- 优先使用异步查询方法
- 合理使用 `select_related` 和 `prefetch_related`
- 避免 N+1 查询问题

```python
# 推荐的查询方式
users = await User.filter(is_active=True).prefetch_related("roles")

# 避免的查询方式（N+1 问题）
users = await User.filter(is_active=True)
for user in users:
    roles = await user.roles.all()  # N+1 查询
```

## 📝 Pydantic 模式规范

### Schema 组织

```python
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class UserBase(BaseModel):
    username: str = Field(..., description="用户名", min_length=1, max_length=20)
    email: str = Field(..., description="邮箱")

class UserCreate(UserBase):
    password: str = Field(..., description="密码", min_length=6)

class UserUpdate(BaseModel):
    username: Optional[str] = None
    email: Optional[str] = None

class UserResponse(UserBase):
    id: int
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True
```

### 验证规则

- 使用 `Field()` 定义验证规则
- 提供清晰的错误描述
- 合理设置默认值

## 🔧 工具函数规范

### 密码处理

```python
from app.utils.password import verify_password, hash_password

# 密码验证
if not verify_password(plain_password, hashed_password):
    raise HTTPException(status_code=401, detail="密码错误")

# 密码加密
hashed_password = hash_password(plain_password)
```

### JWT 处理

```python
from app.utils.jwt_utils import create_access_token, decode_token

# 创建令牌
token = create_access_token(data={"sub": str(user.id)})

# 解析令牌
payload = decode_token(token)
```

## 📋 代码质量要求

### 文档字符串

- 所有公共函数和类必须有文档字符串
- 使用 Google 风格的文档字符串

```python
async def create_user(user_data: UserCreate) -> User:
    """创建新用户

    Args:
        user_data: 用户创建数据

    Returns:
        User: 创建的用户对象

    Raises:
        HTTPException: 当用户名已存在时
    """
    # 实现逻辑
    pass
```

### 错误处理

- 使用明确的异常类型
- 提供有意义的错误消息
- 记录适当的错误日志

### 性能考虑

- 异步函数优先使用 `async/await`
- 数据库查询使用连接池
- 大数据集必须分页处理
- 合理使用缓存机制

### 安全规范

- 敏感信息不写入日志
- 使用参数化查询防止 SQL 注入
- 验证所有用户输入
- 实施适当的权限检查
